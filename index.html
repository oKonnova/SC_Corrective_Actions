<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Tokenomics Live Demo</title>
    <!-- React and ReactDOM -->
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <!-- Ethers.js for blockchain interaction -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Babel to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- TensorFlow.js for the neural network -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <style>
        /* Custom styles for a polished look */
        body {
            background-color: #f8fafc; /* A light gray background */
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        .card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status-log {
            height: 200px;
            background-color: #1a202c;
            color: #a0aec0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-y: scroll;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const App = () => {
            // --- STATE MANAGEMENT ---
            const [isLoading, setIsLoading] = useState(true);
            const [logs, setLogs] = useState(["Initializing..."]);
            const [model, setModel] = useState(null);
            const [scaler, setScaler] = useState(null);
            const [chartData, setChartData] = useState(null);
            const [chartInstance, setChartInstance] = useState(null);
            const chartRef = useRef(null);

            // --- CONFIGURATION (REPLACE WITH YOUR ACTUAL DATA) ---
            // IMPORTANT: You must deploy your SubscriptionManager contract TWICE.
            const TOKEN_ADDRESS = '0x5031B2560a72450659D68F8d290f218143E5E19F'; // Your SCPlusToken address
            const SUBSCRIPTION_ADDRESS = '0xd21687210FDc0367C6175bF5a7E0577F96C3f0Ed'; // Address of the contract that WILL use AI actions.
            const SUBSCRIPTION_NO_ACTION_ADDRESS = '0xA8059A9E7E0AE1B55B33b3CC7E2873E5923E7c16'; // Address of the second contract that WILL NOT use AI actions (the control).
            const EXCHANGE_ADDRESS = '0xd1B4561DfcCe893F51e74b0Ce399be749A3c61Ec'; // Address of the account that can approve tokens for buy-back.

            // --- CONSTANTS ---
            const ACTION_MAP = {
                0: "No Action", 1: "Lower Subscription Price", 2: "Raise Subscription Price",
                3: "Sell 10% Reserve", 4: "Buy-Back Tokens", 5: "Sell 20% Reserve"
            };

            const scenarios = [
                { name: "Month 1", userChange: 0.05, priceChange: 0.03 }, { name: "Month 2", userChange: 0.10, priceChange: 0.08 },
                { name: "Month 3", userChange: -0.10, priceChange: -0.15 }, { name: "Month 4", userChange: 0.08, priceChange: 0.10 },
                { name: "Month 5", userChange: 0.12, priceChange: 0.07 }, { name: "Month 6", userChange: 0.18, priceChange: 0.15 },
                { name: "Month 7", userChange: -0.15, priceChange: -0.20 }, { name: "Month 8", userChange: 0.05, priceChange: 0.04 },
                { name: "Month 9", userChange: 0.15, priceChange: 0.12 }, { name: "Month 10", userChange: 0.20, priceChange: 0.18 },
                { name: "Month 11", userChange: -0.08, priceChange: -0.12 }, { name: "Month 12", userChange: 0.25, priceChange: 0.20 }
            ];

            const SUBSCRIPTION_ABI = [
                "function applyCorrectiveAction(uint256 action) external", "function tokenPriceUSD() view returns (uint256)",
                "function lastTokenPrice() view returns (uint256)", "function activeUsers() view returns (uint256)",
                "function lastActiveUsers() view returns (uint256)", "function fiatAmount() view returns (uint256)",
                "function tokenAmount() view returns (uint256)", "function reserveBalance() view returns (uint256)",
                "function setFiatAmount(uint256 _fiatAmount) external", "function setLastTokenPrice(uint256 _lastTokenPrice) external",
                "function simulateUserDrop(uint256 users) external", "function simulateUserIncrease(uint256 users) external"
            ];

            const TOKEN_ABI = ["function approve(address spender, uint256 amount) external returns (bool)"];

            // --- LOGGING UTILITY ---
            const log = (message) => {
                console.log(message);
                setLogs(prev => [...prev, `[${new Date().toLocaleTimeString()}] ${message}`]);
            };

            // --- INITIALIZATION ---
            useEffect(() => {
                async function initialize() {
                    log('Loading AI model and scaler...');
                    try {
                        const loadedModel = await tf.loadLayersModel('tfjs_model/model.json');
                        const scalerResponse = await fetch('scaler.json');
                        if (!scalerResponse.ok) throw new Error(`scaler.json not found (status: ${scalerResponse.status})`);
                        const loadedScaler = await scalerResponse.json();
                        
                        setModel(loadedModel);
                        setScaler(loadedScaler);
                        log('✅ Model and scaler loaded successfully.');
                    } catch (error) {
                        log(`❌ Error loading model/scaler: ${error.message}`);
                    } finally {
                        setIsLoading(false);
                    }
                }
                initialize();
            }, []);

            // --- CHART RENDERING ---
            useEffect(() => {
                if (chartData && chartRef.current) {
                    if (chartInstance) chartInstance.destroy();
                    const ctx = chartRef.current.getContext('2d');
                    const newChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: chartData,
                        options: {
                            responsive: true,
                            plugins: {
                                legend: { position: 'top' },
                                title: { display: true, text: 'Token Price Simulation: AI vs. No AI', font: { size: 18 } }
                            },
                            scales: {
                                y: {
                                    beginAtZero: false,
                                    title: { display: true, text: 'Token Price (USD)' },
                                    ticks: { callback: value => '$' + value.toFixed(2) }
                                }
                            }
                        }
                    });
                    setChartInstance(newChartInstance);
                }
            }, [chartData]);

            // --- AI PREDICTION LOGIC ---
            const predictAction = async (inputData) => {
                if (!model || !scaler) {
                    log("Model or scaler not ready.");
                    return 0;
                }
                const featuresArray = [inputData.lastUsers, inputData.prevUsers, inputData.priceChange, inputData.prevPriceChange];
                return tf.tidy(() => {
                    const features = tf.tensor2d([featuresArray], [1, 4], 'float32');
                    const mean = tf.tensor1d(scaler.mean.slice(0, 4), 'float32');
                    const scale = tf.tensor1d(scaler.scale.slice(0, 4), 'float32');
                    const scaledFeatures = features.sub(mean).div(scale);
                    const prediction = model.predict(scaledFeatures);
                    return prediction.argMax(-1).dataSync()[0];
                });
            };
            
            // --- CORE SIMULATION LOGIC ---
            const runSingleScenario = async (provider, scenario, contractAddress, useAiAction) => {
                const logPrefix = useAiAction ? "[AI]" : "[Control]";
                const signer = provider.getSigner();
                const subscription = new ethers.Contract(contractAddress, SUBSCRIPTION_ABI, signer);
                const token = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, signer);

                log(`${logPrefix} Running: ${scenario.name}`);

                const initialPrice = await subscription.tokenPriceUSD();
                const currentTokenAmount = await subscription.tokenAmount();
                
                const targetPriceUSD = initialPrice.mul(Math.round((1 + scenario.priceChange) * 100)).div(100);
                const newFiatAmount = targetPriceUSD.mul(currentTokenAmount).div(ethers.utils.parseUnits("1", 18));
                
                let tx = await subscription.setLastTokenPrice(initialPrice);
                await tx.wait();
                tx = await subscription.setFiatAmount(newFiatAmount);
                await tx.wait();

                const currentUsers = await subscription.activeUsers();
                const targetUsers = Math.max(10, Math.round(currentUsers.toNumber() * (1 + scenario.userChange)));
                const userChange = targetUsers - currentUsers.toNumber();
                
                if (userChange < 0) {
                    tx = await subscription.simulateUserDrop(Math.abs(userChange));
                } else if (userChange > 0) {
                    tx = await subscription.simulateUserIncrease(userChange);
                }
                await tx.wait();
                
                if (useAiAction) {
                    const updatedState = {
                        lastUsers: (await subscription.activeUsers()).toNumber(),
                        prevUsers: (await subscription.lastActiveUsers()).toNumber(),
                        priceChange: scenario.priceChange,
                        prevPriceChange: 0
                    };
                    const actionToApply = await predictAction(updatedState);
                    log(`${logPrefix} 🧠 AI Predicted Action: ${ACTION_MAP[actionToApply]}`);
                    
                    if (actionToApply === 4) {
                        log(`${logPrefix} Approving tokens for buy-back...`);
                        const exchangeSigner = provider.getSigner(EXCHANGE_ADDRESS);
                        tx = await token.connect(exchangeSigner).approve(contractAddress, ethers.utils.parseUnits("20000", 18));
                        await tx.wait();
                    }
                    
                    tx = await subscription.applyCorrectiveAction(actionToApply);
                    await tx.wait();
                    log(`${logPrefix} 🚀 Action applied on-chain.`);
                }

                const finalPrice = await subscription.tokenPriceUSD();
                log(`${logPrefix} Final price for this step: $${ethers.utils.formatUnits(finalPrice, 8)}`);
                return parseFloat(ethers.utils.formatUnits(finalPrice, 8));
            };

            const handleRunAll = async () => {
                if (!window.ethereum) return log("❌ MetaMask is not installed.");
                if (SUBSCRIPTION_NO_ACTION_ADDRESS === '0x...') return log("❌ Please set the second contract address.");
                setIsLoading(true);
                setChartData(null); // Clear previous chart
                log("--- STARTING PARALLEL SIMULATION ---");
                
                try {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    await provider.send("eth_requestAccounts", []);
                    log("Wallet connected.");
                    log("NOTE: This demo requires both contracts to be in their initial, identical states for a valid comparison.");

                    const pricesWithAi = [];
                    const pricesWithoutAi = [];

                    for (const scenario of scenarios) {
                        log(`\n--- SCENARIO: ${scenario.name} ---`);
                        
                        // Run on AI contract
                        const priceAi = await runSingleScenario(provider, scenario, SUBSCRIPTION_ADDRESS, true);
                        pricesWithAi.push(priceAi);

                        // Run on Control contract
                        const priceNoAi = await runSingleScenario(provider, scenario, SUBSCRIPTION_NO_ACTION_ADDRESS, false);
                        pricesWithoutAi.push(priceNoAi);
                    }

                    // Update chart with final results
                    setChartData({
                        labels: scenarios.map(s => s.name),
                        datasets: [
                            {
                                label: 'Price with AI Actions',
                                data: pricesWithAi,
                                borderColor: 'rgb(59, 130, 246)',
                                backgroundColor: 'rgba(59, 130, 246, 0.5)',
                                tension: 0.2,
                                borderWidth: 2.5
                            },
                            {
                                label: 'Price without AI (Control)',
                                data: pricesWithoutAi,
                                borderColor: 'rgb(239, 68, 68)',
                                backgroundColor: 'rgba(239, 68, 68, 0.5)',
                                tension: 0.2,
                                borderWidth: 2.5,
                                borderDash: [5, 5]
                            }
                        ]
                    });
                    log("\n✅ Full simulation complete. Chart updated.");

                } catch (error) {
                    log(`❌ An error occurred: ${error.message}`);
                    console.error(error);
                } finally {
                    setIsLoading(false);
                }
            };
            
            return (
                <div className="p-4 md:p-8 max-w-7xl mx-auto">
                    <header className="text-center mb-8">
                        <h1 className="text-4xl font-bold text-gray-800">AI-Powered Tokenomics Engine</h1>
                        <p className="text-lg text-gray-500 mt-2">Live A/B Test on the Sepolia Testnet</p>
                    </header>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        <div className="lg:col-span-1">
                            <div className="card">
                                <h2 className="text-2xl font-semibold text-gray-700 mb-4">Controls</h2>
                                <button
                                    className="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg btn"
                                    onClick={handleRunAll}
                                    disabled={isLoading || !model}
                                >
                                    {isLoading ? 'Simulation in Progress...' : '▶️ Run A/B Test Simulation'}
                                </button>
                                <div className="mt-4 space-y-2">
                                     <a href={`https://sepolia.etherscan.io/address/${SUBSCRIPTION_ADDRESS}`} target="_blank" rel="noopener noreferrer" className="block w-full text-center bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg btn">
                                        View AI Contract on Etherscan
                                    </a>
                                </div>
                            </div>
                            <div className="card">
                                <h2 className="text-2xl font-semibold text-gray-700 mb-4">Live Status Log</h2>
                                <div className="status-log">
                                    {logs.map((logMsg, i) => <div key={i}>{logMsg}</div>)}
                                </div>
                            </div>
                        </div>

                        <div className="lg:col-span-2">
                            <div className="card">
                                <h2 className="text-2xl font-semibold text-gray-700 mb-4">Simulation Results</h2>
                                {chartData ? (
                                    <canvas ref={chartRef}></canvas>
                                ) : (
                                    <div className="text-center py-16 text-gray-500">
                                        <p>A/B test chart will be displayed here after running the simulation.</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
